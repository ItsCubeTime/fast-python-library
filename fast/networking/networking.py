import socket
import fast
import time
import typing


def urlEncode(string: str):
    '''
    "C:/Users/olliv/AppData/Local/Programs/Python/Python310/lib/site-packages/fast/data/readyFox32px.pngðŸ’–*^#=)))))(/&%Â¤Ã…Ã„Ã–)"
    would become:
    C%3A/Users/olliv/AppData/Local/Programs/Python/Python310/lib/site-packages/fast/data/readyFox32px.png%F0%9F%92%96%2A%5E%23%3D%29%29%29%29%29%28/%26%25%C2%A4%C3%85%C3%84%C3%96%29
    '''
    if isinstance(string, bytes):
        string = string.decode()
    import urllib
    returnVal: str = urllib.parse.quote_plus(str(string))
    returnVal = returnVal.replace(r"%2F", "/")  # We actually want to keep slashes to maintain decent readability in the final url
    return str(returnVal)


def urlDecode(string: str):
    '''
    Encoded string generatd by urlEncode:
    C%3A/Users/olliv/AppData/Local/Programs/Python/Python310/lib/site-packages/fast/data/readyFox32px.png%F0%9F%92%96%2A%5E%23%3D%29%29%29%29%29%28/%26%25%C2%A4%C3%85%C3%84%C3%96%29
    would be brought to its original state:
    "C:/Users/olliv/AppData/Local/Programs/Python/Python310/lib/site-packages/fast/data/readyFox32px.pngðŸ’–*^#=)))))(/&%Â¤Ã…Ã„Ã–)"
    '''
    # if isinstance(string, bytes):
        # string = string.decode()
    import urllib
    returnVal: str = str(string).replace("/", r"%2F")
    returnVal = urllib.parse.unquote_plus(returnVal)
    return str(returnVal)

from contextlib import closing
   
def isPortOpen(adress='0.0.0.0', port=80):
    # with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
        # if sock.connect_ex((adress, port)) == 0:
        #     return True
        # else:
        #     return False
    try:
        tsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tsock.bind((adress, port)) 
        tsock.close()  
        return False 
    except:    
        return True

class FastSocket:
    """A socket.socket wrapper that creates a UDP socket that supports multicasting, binds it to a multicast adress & allows for
    sending messages over that multicast adress.

    Also sets up the TCP socket to forward messages to the multicast adress.

    The TCP & UDP socket shares port & adress. The Multicast adress is UDP & uses an identical adress to the TCP/UDP adresses, except
    replacing the first portion of the url with 224. So 0.0.0.1 would yield a multicast adress of 224.0.0.1 & 127.5.12.121 would become
    224.5.12.121

    Assumes IPv4 style adresses, like: 0.0.0.0 or 127.0.0.1.


    At the end of the day, what this enables is creating multiple instances of this very class bound to the same adress & port
    running across multiple python instances to enable cross process communication with greater ease than what using the socket
    library directly would ever enable - 1 function call with 2 arguments and youre all ready to send messages!


    If no adress & port is chosen, the OS will pick one for you. However this does not take the multicast & TCP adresses into account.

    Therefore, when setting up the first socket acting on an IP, I recommend either manually picking a local IP & port or
    calling FastGetAvailableAdress() which returns an adress & a port that will be guaranteed to work with this class. 
    Then store that somewhere thats accessible to all processes and use it as adress & port for all fastSockets.


    Should be quite fast since were using UDP for sending & receiving messages, though, this is Python so it wont be faster than the 
    interpreter. Only exception being TCP requests sent from external tools ofc. 

    Note that UDP doesnt check for package integrity, so theres a possibility that packages gets lost or damaged, though
    Im yet to see this happen when running locally on the machine.

    """
    
    def __init__(self, adress='0.0.0.0', port=0, receive: typing.Callable = lambda self, message: print(f"'{message}' socket message received from {self.adress}:{self.port}"), sendTimeoutPreventionPings=False, timeoutCb: typing.Callable = None, timeoutDurationSeconds: float = 1, key:str=None) -> None:
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        # allow multiple sockets to use the same PORT number
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind((adress, port))
        # tell the kernel that we are a multicast socket
        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255)
        # self.sock.connect((adress, port))

        self.madress = "224" + self.adress[self.adress.find("."):]
        "Multicast adress, generated by the adress fed in. 0.0.0.1 would become 237.0.0.1. 127.5.3.5 would become 237.5.3.5."
        print(self.madress)
        # Tell the kernel that we want to add ourselves to a multicast group
        # The address for the multicast group is the third param
        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP,
                             socket.inet_aton(self.madress) + socket.inet_aton(self.adress))
        # self.sock.listen(5)
        self.receive = receive

        try:
            # Its not necessarily bad if we fail to setup the TCP port, but if no "FastSocket" manages to set it up, we wont
            # be able to communicate over TCP sockets, which is required by webbrowser requests.
            self.tsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.tsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.tsock.bind((self.adress, self.port))
            self.tsock.listen(5)
            fast.asyncronous.runAsync(self._tlistenLoop)
        except Exception as exception:
            print("Failed to setup TCP port", exception)

        fast.asyncronous.runAsync(self._listenLoop)

        # Timeout related BEGIN
        self.lastReceivedMessageTime = 0
        self.timeoutDurationSeconds = timeoutDurationSeconds
        if timeoutCb != None:
            self.timeoutCb = timeoutCb
            fast.asyncronous.runAsync(self._timeoutLoop)
        else:
            self.timeoutCb = lambda: None # We are still setting these values in case someone ever tries to access self.timeoutDuration or
            # call timeout() manually (we dont want it to raise an exception)

        if sendTimeoutPreventionPings: # Even if this instance isn't listening to timeout messages, another instance might still want to receive them.
            fast.asyncronous.runAsync(self._timeoutSenderLoop)
        # Timeout related END

    def _timeoutSenderLoop(self):
        while True:
            time.sleep(self.timeoutDurationSeconds)
            self.send(b"timeout*.-_")

    def _timeoutLoop(self):
        while True:
            time.sleep(self.timeoutDurationSeconds)
            if self.lastReceivedMessageTime + self.timeoutDurationSeconds < time.time():
                self.timeoutCb()

    receive: typing.Callable
    "Set me to a function"

    def _tlistenLoop(self):
        while (1):
            self._tlisten()

    def _tlisten(self):
        (clientsocket, address) = self.tsock.accept()

        rd = clientsocket.recv(5000)
        self.send(rd)

    def _listenLoop(self):
        while (1):
            self._listen()

    def _listen(self):
        data, addr = self.sock.recvfrom(1024)
        try:
            data = data.decode()
        except:
            pass
        import inspect
        isMethod = inspect.ismethod(self.receive)
        argCount = self.receive.__code__.co_argcount

        self.lastReceivedMessageTime = time.time()
        if data == b"timeout*.-_":
            return
        if (argCount > 2 and not isMethod) or (isMethod and argCount > 3):
            self.receive(self, data, addr)
        else:
            # print(f"decoded to type: {type(data.decode())}")
            self.receive(self, data)

    def send(self, message):
        self.sock.sendto(message if isinstance(message, bytes) else str(message).encode(), (self.madress, self.port))

    @property
    def adress(self):
        return self.sock.getsockname()[0]

    @property
    def port(self):
        return self.sock.getsockname()[1]


# fastSocket = FastSocket(port=80)
# time.sleep(1)
# fastSocket.send(f"Hi!!! {fastSocket.port}")


# @note It looks like we will need to use a F
class NamedSocket():
    """WARNING: This class is NOT complete. Do not use. Currently considering to try and implement NamedSocket on top of FastSocket instead & ignore potential overhead.
    
    NamedSockets run on a single shared hardcoded TCP port & filter incoming requests based on request prefixes."""
    def __init__(self, name:str, remoteAdress:str='127.0.0.1', receiveCb=lambda m: print(f"Received '{m}'"), localAdress:str='127.0.0.1', localPort=2739, remotePort=2739):
        self.name         = name
        self.receiveCb    = receiveCb
        self.remoteAdress = remoteAdress
        self.localAdress  = localAdress
        self.localPort    = localPort
        self.remotePort   = remotePort

        
        self._incomingSocketIsActive = True
        self._incomingSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # self._incomingSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._incomingSocket.bind((self.localAdress, self.localPort))
        self._incomingSocket.listen(5)
        fast.asyncronous.runAsync(self._listenLoop)
    def __del__(self):
        self._incomingSocket.close()
        self._incomingSocketIsActive = False

    def sendLocal(self, message: str):
        # self._incomingSocket.connect((self.localAdress, self.localPort))
        # self._incomingSocket.sendall(message if isinstance(message, bytes) else str(message).encode())
        host = self.localAdress
        port = self.localPort        # The same port as used by the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port))
        s.sendall(bytes(message, encoding='utf-8'))
        # data = s.recv(1024)
        s.close()


    def _listenLoop(self):
        while (self._incomingSocketIsActive):
            self._listen()

    def _listen(self):
        # (clientsocket, address) = self._incomingSocket.accept()
        # data, addr = self._incomingSocket.recvfrom(1024)
        # if self.receive.__code__.co_argcount > 2:
        #     self.receive(self, data.decode(), addr)
        # else:
        #     self.receive(self, data.decode())
        try:
            (clientsocket, address) = self._incomingSocket.accept()
            rd = clientsocket.recv(5000)
            self.receiveCb(rd)
        except Exception as exc:
            if not str(exc).__contains__('not a socket'):
                raise exc
# from fast import asyncronous
# ns = NamedSocket(name='cashflow')
# ns = NamedSocket(name='cashflow')
# asyncronous.runAsync(lambda: 
# time.sleep(0.5)
# ns.sendLocal('hi')
# print("end")
# time.sleep(0.2)
# ns._incomingSocket.close()
# ns.__del__()

# fs = FastSocket(port=3333).send("hi")